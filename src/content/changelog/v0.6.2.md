---
version: "0.6.2"
date: 2025-11-15
title: "Pattern Matching and Error Handling"
description: "Comprehensive pattern matching, error handling system, and destructuring assignment"
breaking: true
status: "Unreleased"
highlights:
  - "Comprehensive Pattern Matching"
  - "Error Handling System"
  - "Destructuring Assignment"
  - "Guard Clause Syntax Change"
---

## New Features

### Comprehensive Pattern Matching

Full `match` expression with pattern-based control flow:

- Literal patterns for numbers, strings, and booleans
- Variable binding patterns with scoped bindings
- Wildcard pattern `_` for catch-all cases
- Record destructuring with nested patterns
- Vector/array patterns with rest syntax (`...tail`)
- Type patterns (Number, String, Boolean, Error, etc.)
- Guard clauses with `if` conditions
- First-match-wins semantics

**Pattern Matching Examples**
```javascript
// Literal and guard patterns
match x {
    0 => "zero",
    n if (n > 0) => "positive",
    _ => "negative"
}

// Record destructuring
match person {
    { name: n, age: a } if (a >= 18) => n + " (adult)",
    { name: n } => n + " (minor)",
    _ => "unknown"
}

// Vector patterns with rest
match list {
    [] => "empty",
    [head, ...tail] => head
}

// Type patterns
match value {
    Number => "number",
    String => "string",
    Error => "error",
    _ => "other"
}
```

### Comprehensive Error Handling System

- Added `try/catch/throw` expressions for robust error management
- `throw` statement for explicit error throwing with structured data
- `Error` type as first-class value with `message`, `kind`, and `source` fields
- Expression-based try/catch returns value from either block
- Runtime errors (division by zero, type errors) automatically caught
- Error type integration with gradual type system

**Error Value Structure**
```javascript
// Simple throw
throw "Error message"

// Structured throw
throw { message: "Invalid input", kind: "ValidationError" }

// Try/catch expression
let result = try { riskyOp() } catch (e) { "default" }

// Access error fields
catch (e) { e.message + " (" + e.kind + ")" }
```

**Error Type in Type System**
- `Error` type annotation for variables and function signatures
- Union types with Error: `Number | Error`
- Runtime type checking: `typeof(error)` returns "Error"
- Type aliases: `type Result = Number | Error`

### Destructuring Assignment

Pattern-based destructuring in `let` and `mut` bindings:

- Record destructuring: `let { name, age } = person`
- Vector destructuring with rest: `let [head, ...tail] = list`
- Nested patterns: `let { user: { name: n } } = data`
- Partial matching: `let { x } = { x: 1, y: 2, z: 3 }`
- Mutable destructuring: `mut { x, y } = point`
- Wildcard support: `let [first, _, third] = triple`

**Destructuring Examples**
```javascript
// Extract from records
let person = { name: "Alice", age: 30, city: "NYC" }
let { name, age } = person

// Split arrays
let list = [1, 2, 3, 4, 5]
let [head, ...tail] = list  // head=1, tail=[2,3,4,5]

// Nested extraction
let data = { result: { value: 42 } }
let { result: { value: v } } = data  // v=42
```

## Breaking Changes

### Guard Clause Syntax

Guard conditions now require parentheses: `if (condition)` instead of `if condition`

- This eliminates ambiguity with lambda arrow `=>` in expressions
- Consistent with if-statement syntax: `if (cond) { ... }`
- Example: `{ x: a, y: b } if (a == b) => "equal"`
